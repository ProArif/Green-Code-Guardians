t.test(typeA, typeB, alt="l")
t.test(typeA, typeB)
mean(typeA)
mean(typeB)
t.test(typeA, typeB, alternative = "two.sided")
t.test(typeA, typeB, var.equal=FALSE)
t.test(typeA, typeB, var.equal=TRUE)
t.test(typeA, typeB)
?t.test
t.test(typeA, typeB, alt="g")
t.test(typeA, typeB, alt="l")
t.test(typeB, typeA, alt="l")
t.test(typeB, typeA)
t.test(typeB, typeA, alt="l")
t.test(typeB, typeA, alt="g")
boxplot(type A)
boxplot(typeA)
boxplot(typeB)
par(mfrow=c(1,2))
boxplot(typeA)
boxplot(typeB)
t.test(typeB, typeA)
threatA = c(0.48,0.21,0.40,0.25,0.44,0.23,0.27,0.37,0.28,0.13,0.21,0.17,0.14,0.05)
threatB= c(0.34,0.26,0.31,0.35,0.36,0.23,0.44,0.17,0.58,0.28)
t.test(threatA, threatB)
source("~/.active-rstudio-document")
t.test(x, y)
wilcox.test(x, y)
x=rnorm(24,mean=0.6, sd=0.51)
y=rnorm(24,mean=1.48, sd=0.73)
wilcox.test(x, y)
x=rnorm(4,mean=0.6, sd=0.51)
y=rnorm(4,mean=1.48, sd=0.73)
wilcox.test(x, y)
wilcox.test(x, y)
x=rnorm(4,mean=0.6, sd=0.51)
y=rnorm(4,mean=1.48, sd=0.73)
t.test(x, y)
wilcox.test(x, y)
x=rnorm(24,mean=0.6, sd=0.51)
y=rnorm(24,mean=1.48, sd=0.73)
t.test(x, y)
wilcox.test(x, y)
x=rnorm(14,mean=0.6, sd=0.51)
y=rnorm(14,mean=1.48, sd=0.73)
t.test(x, y)
wilcox.test(x, y)
t.test(x, y, alt='l')
t.test(x, y, alt='g')
wilcox.test(x, y, alt='l')
a=rnorm(14,mean=0.55, sd=0.25)
b=rnorm(14,mean=0.26, sd=0.144)
wilcox.test(a, b, alt='g')
a=rnorm(50,mean=0.55, sd=0.25)
b=rnorm(50,mean=0.26, sd=0.144)
wilcox.test(a, b, alt='g')
a=rnorm(1,mean=0.55, sd=0.25)
b=rnorm(1,mean=0.26, sd=0.144)
wilcox.test(a, b, alt='g')
a=rnorm(5,mean=0.55, sd=0.25)
b=rnorm(5,mean=0.26, sd=0.144)
wilcox.test(a, b, alt='g')
a=rnorm(6,mean=0.55, sd=0.25)
b=rnorm(6,mean=0.26, sd=0.144)
wilcox.test(a, b, alt='g')
a=rnorm(6,mean=0.5, sd=0.2)
b=rnorm(6,mean=0.48, sd=0.2)
wilcox.test(a, b, alt='g')
a=rnorm(6,mean=0.24, sd=0.064)
b=rnorm(6,mean=0.24, sd=0.064)
wilcox.test(a, b, alt='g')
a=rnorm(6,mean=0.24, sd=0.064)
b=rnorm(6,mean=0.24, sd=0.064)
wilcox.test(a, b, alt='g')
a=rnorm(6,mean=0.95, sd=0.068)
b=rnorm(6,mean=0.77, sd=0.068)
wilcox.test(a, b, alt='g')
a=rnorm(6,mean=0.95, sd=0.068)
b=rnorm(6,mean=0.77, sd=0.068)
wilcox.test(a, b, alt='g')
a=rnorm(6,mean=0.61, sd=0.317)
b=rnorm(6,mean=0.50, sd=0.256)
wilcox.test(a, b, alt='g')
a=rnorm(6,mean=0.95, sd=0.068)
b=rnorm(6,mean=0.77, sd=0.068)
wilcox.test(a, b, alt='g')
a=rnorm(6,mean=0.95, sd=0.068)
b=rnorm(6,mean=0.77, sd=0.068)
wilcox.test(a, b, alt='g')
a=rnorm(5,mean=0.95, sd=0.068)
b=rnorm(5,mean=0.77, sd=0.068)
wilcox.test(a, b, alt='g')
a=rnorm(5,mean=0.95, sd=0.068)
b=rnorm(5,mean=0.77, sd=0.068)
wilcox.test(a, b, alt='g')
attach(data)
plot(longitude, latitude, col=2, pch=20, cex=0.5, ylim=c(0,60), xlim=c(-100,10))
library(rworldmap)
plot(getMap(), asp = 1, add=T, col="gray60")
getwd()
data <- read.csv("/Users/asror_akb/Downloads/tritium.csv")
attach(data)
plot(longitude, latitude, col=2, pch=20, cex=0.5, ylim=c(0,60), xlim=c(-100,10))
library(rworldmap)
plot(getMap(), asp = 1, add=T, col="gray60")
library(rworldmap)
install.packages("rworldmap")
library(rworldmap)
plot(getMap(), asp = 1, add=T, col="gray60")
data <- read.csv("/Users/asror_akb/Downloads/tritium.csv")
attach(data)
plot(longitude, latitude, col=2, pch=20, cex=0.5, ylim=c(0,60), xlim=c(-100,10))
library(rworldmap)
plot(getMap(), asp = 1, add=T, col="gray60")
lm2$coefficients[1]\
lm2$coefficients[1]\
x<-pressure
y<-tritium
NW_CV <- function(x,y,h){
n <- length(x)
mcv <- rep(0,n)
for(i in 1:n){
mcv[i] <- ksmooth(x[-i], y[-i], kernel="normal",
bandwidth=h, x.points=x[i])$y
}
cv <- mean((y-mcv)^2)
return(cv)
}
min_h <- optim(par=0.3, fn=function(h) NW_CV(x,y,h), method="BFGS")
(h_cv <- min_h$par)
min_h$value
xval <- seq(min(x),max(x))
llest <- rep(NA, length(xval))
m_d <- rep(NA, length(xval))
h <- 0.176
for(i in 1:length(xval)){
z <- x-xval[i]
w <- dnorm((xval[i]-x)/h)
z2 <- z^2
wls <- lm(y~z  , weights = w)
m_d[i] <- wls$coef[2]*z
#llest[i] <- predict(wls,z)
llest[i] <- wls$coef[1]
}
plot(x,y, xlab="pressure", ylab="tritium")
points(xval,llest,type = "l",col=2,lwd=2)
points(xval,m_d,type = "l",col=3)
wls$coef[2]
wls$coef[1]
install.packages("interp")
?(locpoly)
loclinear2 <- locpoly(tritium,pressure,bandwidth = h_cv, degree = 2 )
lm2<- lm(tritium~pressure)
lm2
lm2$coefficients[1]\
points(xval,m_d,type = "l",col=3)
wls$coef[2]
wls$coef[1]
install.packages("interp")
?(locpoly)
loclinear2 <- locpoly(tritium,pressure,bandwidth = h_cv, degree = 2 )
lm2<- lm(tritium~pressure)
loclinear2 <- locpoly(tritium,pressure,bandwidth = h_cv, degree = 2 )
lm2<- lm(tritium~pressure)
lm2
for(i in 1:length(xval)){
z <- x-xval[i]
w <- dnorm((xval[i]-x)/h)
z2 <- z^2
wls <- lm(y~z  , weights = w)
m_d[i] <- wls$coef[2]*z
llest[i] <- predict(wls,z)
#llest[i] <- wls$coef[1]
}
plot(x,y, xlab="pressure", ylab="tritium")
points(xval,llest,type = "l",col=2,lwd=2)
points(xval,m_d,type = "l",col=3)
wls$coef[2]
xval <- seq(min(x),max(x))
llest <- rep(NA, length(xval))
m_d <- rep(NA, length(xval))
h <- 0.176
for(i in 1:length(xval)){
z <- x-xval[i]
w <- dnorm((xval[i]-x)/h)
wls <- lm(y~z, weights = w)
m_d[i] <- wls$coef[2]*z
#llest[i] <- wls$coef[1]
llest[i] <- predict(wls$coef[1])
}
plot(x,y, xlab="pressure", ylab="tritium")
points(xval,llest,type = "l",col=2,lwd=2)
points(xval,m_d,type = "l",col=3)
x<-pressure
y<-tritium
xval <- seq(min(x),max(x))
llest <- rep(NA, length(xval))
m_d <- rep(NA, length(xval))
h <- 0.176
for(i in 1:length(xval)){
z <- x-xval[i]
w <- dnorm((xval[i]-x)/h)
wls <- lm(y~z, weights = w)
m_d[i] <- wls$coef[2]*z
#llest[i] <- wls$coef[1]
llest[i] <- predict(wls$coef[1])
}
plot(x,y, xlab="pressure", ylab="tritium")
points(xval,llest,type = "l",col=2,lwd=2)
points(xval,m_d,type = "l",col=3)
set.seed(1)
n <- 101
x<-pressure
y<-tritium
fx <- sin(2 * pi * x)
# define x* and color for window
xstar <- 0.3
cols <- rgb(190/255,190/255,190/255,alpha=0.5)
# set-up 2 x 2 subplot
par(mfrow = c(2,2))
# loop through spans (0.1, 0.2, 0.3, 0.4)
for(s in c(0.1, 0.2, 0.3, 0.4)){
# plot data and true function
plot(x, y, main = paste0("span = ", s), ylim = c(-2.5, 2.5),
cex.lab = 1.5, cex.axis = 1.25)
lines(x, fx, col = "blue", lwd = 2)
# plot window
window <- c(xstar - s / 2, xstar + s / 2)
rect(window[1], -3, window[2], 3, col = cols)
# define weights
w <- tricube(x - xstar, delta = s / 2)
# plot estimate
X <- cbind(1, x - 0.5, (x - 0.5)^2)
X.w <- sqrt(w) * X
y.w <- sqrt(w) * y
beta <- solve(crossprod(X.w)) %*% crossprod(X.w, y.w)
ystar <- as.numeric(cbind(1, xstar - 0.5, (xstar - 0.5)^2) %*% beta)
points(xstar, ystar, pch = 17, col = "red", cex = 1)
# add regression line
lines(x, X %*% beta, lty = 3)
# add legend
legend("topright", legend = c("data", "truth"),
pch = c(1, NA), lty = c(NA, 1), col = c("black", "blue"), bty = "n")
legend("bottomright", legend = c("estimate", "window"),
pch = c(17, 15), col = c("red", "gray"), bty = "n")
}
# define function and data
set.seed(1)
n <- 101
x <- seq(0, 1, length.out = n)
fx <- sin(2 * pi * x)
y <- fx + rnorm(n, sd = 0.5)
# define x* and color for window
xstar <- 0.3
cols <- rgb(190/255,190/255,190/255,alpha=0.5)
# set-up 2 x 2 subplot
par(mfrow = c(2,2))
# loop through spans (0.1, 0.2, 0.3, 0.4)
for(s in c(0.1, 0.2, 0.3, 0.4)){
# plot data and true function
plot(x, y, main = paste0("span = ", s), ylim = c(-2.5, 2.5),
cex.lab = 1.5, cex.axis = 1.25)
lines(x, fx, col = "blue", lwd = 2)
# plot window
window <- c(xstar - s / 2, xstar + s / 2)
rect(window[1], -3, window[2], 3, col = cols)
# define weights
w <- tricube(x - xstar, delta = s / 2)
# plot estimate
X <- cbind(1, x - 0.5, (x - 0.5)^2)
X.w <- sqrt(w) * X
y.w <- sqrt(w) * y
beta <- solve(crossprod(X.w)) %*% crossprod(X.w, y.w)
ystar <- as.numeric(cbind(1, xstar - 0.5, (xstar - 0.5)^2) %*% beta)
points(xstar, ystar, pch = 17, col = "red", cex = 1)
# add regression line
lines(x, X %*% beta, lty = 3)
# add legend
legend("topright", legend = c("data", "truth"),
pch = c(1, NA), lty = c(NA, 1), col = c("black", "blue"), bty = "n")
legend("bottomright", legend = c("estimate", "window"),
pch = c(17, 15), col = c("red", "gray"), bty = "n")
}
set.seed(1)
n <- 101
x<-pressure
y<-tritium
fx <- sin(2 * pi * x)
# define x* and color for window
xstar <- 0.3
cols <- rgb(190/255,190/255,190/255,alpha=0.5)
# set-up 2 x 2 subplot
par(mfrow = c(2,2))
# loop through spans (0.1, 0.2, 0.3, 0.4)
for(s in c(0.1, 0.2, 0.3, 0.4)){
# plot data and true function
plot(x, y, main = paste0("span = ", s), ylim = c(-2.5, 2.5),
cex.lab = 1.5, cex.axis = 1.25)
lines(x, fx, col = "blue", lwd = 2)
# plot window
window <- c(xstar - s / 2, xstar + s / 2)
rect(window[1], -3, window[2], 3, col = cols)
# define weights
w <- tricube(x - xstar, delta = s / 2)
# plot estimate
X <- cbind(1, x - 0.5, (x - 0.5)^2)
X.w <- sqrt(w) * X
y.w <- sqrt(w) * y
beta <- solve(crossprod(X.w)) %*% crossprod(X.w, y.w)
ystar <- as.numeric(cbind(1, xstar - 0.5, (xstar - 0.5)^2) %*% beta)
points(xstar, ystar, pch = 17, col = "red", cex = 1)
# add regression line
lines(x, X %*% beta, lty = 3)
# add legend
legend("topright", legend = c("data", "truth"),
pch = c(1, NA), lty = c(NA, 1), col = c("black", "blue"), bty = "n")
legend("bottomright", legend = c("estimate", "window"),
pch = c(17, 15), col = c("red", "gray"), bty = "n")
}
cv.ridge <- cv.glmnet(Xs, y, alpha = 0, nfolds=n, grouped=FALSE, family = binomial)
library(glmnet)
X <- as.matrix(wine_data[,-12])
plot.ts(m1_generation_chatgpt_df)
source("~/VU/Master/GL/Green-Code-Guardians/data/chatgpt/results.R")
# At last print the output dataframe
print(m1_generation_chatgpt_df)
setwd("~/VU/Master/GL/Green-Code-Guardians/data/chatgpt")
load("m1_generation_chatgpt.RData")
sample <- counter_data$sampleGroups[[1]]$samples
install.packages("tidyverse")
install.packages("ggplot2")
library(ggplot2)
library(ggplot2)
load("m1_generation_chatgpt.RData")
sample <- counter_data$sampleGroups[[1]]$samples
colnames(sample) < c("total count", "time", "microwatts")
sample$machine <- "m2"
colnames(sample) < c("total count", "time", "microwatts")
sample$machine <- "m1"
sample$machine <- as.factor(sample$machine)
# sample$machine <- "m1"
# sample$machine <- as.factor(sample$machine)
unlistSample <- unlist(sample$count, use.names=FALSE)
load("m1_generation_chatgpt.RData")
View(m1_generation_chatgpt_data)
library(jsonlite)
# Then we have to load JSON data
m1_generation_chatgpt_data <- fromJSON("m1-generation-chatgpt-formated.json")
# Then convert  the JSON data to dataframe
m1_generation_chatgpt_df <- as.data.frame(m1_generation_chatgpt_data)
save(m1_generation_chatgpt_df, file = 'm1_generation_chatgpt.Rdata')
save(m1_generation_chatgpt_df, file = 'm1_generation_chatgpt.Rdata')
# At last print the output dataframe
print(m1_generation_chatgpt_df)
plot.ts(m1_generation_chatgpt_df)
load("m1_generation_chatgpt.RData")
View(m1_generation_chatgpt_data)
m1_pwu <- m1_generation_chatgpt_df$power.usage
# colnames(sample) < c("total count", "time", "microwatts")
# sample$machine <- "m1"
# sample$machine <- as.factor(sample$machine)
unlist_m1_pwu <- unlist(m1_pwu, use.names=FALSE)
hist(unlist_m1_pwu)
filtered_m1_pwu <- remove_outliers(unlist_m1_pwu)
remove_outliers <- function(data) {
data <- data[data != 0.00]
q <- quantile(data)
iqr <- q[4] - q[2]
lower_bound <- q[2] - 1.5 * iqr
upper_bound <- q[4] + 1.5 * iqr
data_filtered <- data[data >= lower_bound & data <= upper_bound]
return(data_filtered)
}
filtered_m1_pwu <- remove_outliers(unlist_m1_pwu)
hist(filtered_m1_pwu)
m1_knowledge_chatgpt_data <- fromJSON("m1-knowledge-chatgpt-formated.json")
m1_knowledge_chatgpt_df <- as.data.frame(m1_knowledge_chatgpt_data)
save(m1_knowledge_chatgpt_df, file = 'm1_knowledge_chatgpt.Rdata')
plot.ts(m1_knowledge_chatgpt_df)
m1_knowledge_chatgpt_data <- fromJSON("m1-knowledge-chatgpt-formated.json")
m1_knowledge_chatgpt_df <- as.data.frame(m1_knowledge_chatgpt_data)
save(m1_knowledge_chatgpt_df, file = 'm1_knowledge_chatgpt.Rdata')
plot.ts(m1_knowledge_chatgpt_df)
load("m1_knowledge_chatgpt.RData")
m1_k_pwu <- m1_knowledge_chatgpt_df$power.usage
unlist_m1_k_pwu <- unlist(m1_k_pwu, use.names=FALSE)
filtered_m1_k_pwu <- remove_outliers(unlist_m1_k_pwu)
hist(filtered_m1_k_pwu)
setwd("~/VU/Master/GL/Green-Code-Guardians/data")
library(jsonlite)
library(ggplot2)
remove_outliers <- function(data) {
data <- data[data != 0.00]
q <- quantile(data)
iqr <- q[4] - q[2]
lower_bound <- q[2] - 1.5 * iqr
upper_bound <- q[4] + 1.5 * iqr
data_filtered <- data[data >= lower_bound & data <= upper_bound]
return(data_filtered)
}
m1_knowledge_llama_data <- fromJSON("llama/m1-knowledge-llama-formated.json")
m1_knowledge_llama_df <- as.data.frame(m1_knowledge_llama_data)
m1_knowledge_llama_data <- fromJSON("llama/m1-knowledge-llama-formated.json")
m1_knowledge_llama_df <- as.data.frame(m1_knowledge_llama_data)
save(m1_knowledge_llama_df, file = 'llama/m1_knowledge_llama.Rdata')
plot.ts(m1_knowledge_llama_df)
load("chatgpt/m1_knowledge_llama.RData")
m1_lk_pwu <- m1_knowledge_llama_df$power.usage
unlist_m1_lk_pwu <- unlist(m1_lk_pwu, use.names=FALSE)
filtered_m1_lk_pwu <- remove_outliers(unlist_m1_lk_pwu)
hist(filtered_m1_lk_pwu)
log_y <- log10(filtered_m1_lk_pwu)
hist(log_y)
log_y <- log2(filtered_m1_lk_pwu)
hist(log_y)
log_y <- log36(filtered_m1_lk_pwu)
log_y <- log20(filtered_m1_lk_pwu)
log_y <- log5(filtered_m1_lk_pwu)
log_y <- log10(filtered_m1_lk_pwu)
hist(log_y)
cube_y <- filtered_m1_lk_pwu^(1/3)
hist(log_y)
cube_y <- filtered_m1_lk_pwu^(1/3)
hist(cube_y)
sqrt_y <- sqrt(filtered_m1_lk_pwu)
hist(sqrt_y)
log_y <- log(filtered_m1_lk_pwu)
hist(log_y)
log_y <- log(filtered_m1_lk_pwu)
log_x <- log(log_y)
hist(log_x)
log_m <- log(log_m)
hist(log_m)
log_df = log(filtered_m1_lk_pwu)
for (x in 1:10) {
log_df = log(log_df)
}
hist(log_df)
log_df = log(filtered_m1_lk_pwu)
for (x in 1:2) {
log_df = log(log_df)
}
hist(log_df)
log_df = log(filtered_m1_lk_pwu)
for (x in 1:5) {
log_df = log(log_df)
}
log_df = log(filtered_m1_lk_pwu)
for (x in 1:3) {
log_df = log(log_df)
}
hist(log_df)
log_df = log(filtered_m1_lk_pwu)
for (x in 1:4) {
log_df = log(log_df)
}
hist(log_df)
log_df = log(filtered_m1_lk_pwu)
for (x in 1:4) {
log_df = log2(log_df)
}
hist(log_df)
log_df = log(filtered_m1_lk_pwu)
for (x in 1:6) {
log_df = log2(log_df)
}
hist(log_df)
log_df = log(filtered_m1_lk_pwu)
for (x in 1:5) {
log_df = log2(log_df)
}
hist(log_df)
log_df = log(filtered_m1_lk_pwu)
for (x in 1:2) {
log_df = log(log_df)
}
hist(log_df)
for (x in 1:4) {
log_df = log(log_df)
}
log_df = log(filtered_m1_lk_pwu)
for (x in 1:4) {
log_df = log(log_df)
}
log_df = log(filtered_m1_lk_pwu)
for (x in 1:3) {
log_df = log(log_df)
}
hist(log_df)
shapiro.test(log_df)
m1_knowledge_llama_data <- fromJSON("llama/m1-knowledge-llama-formated.json")
m1_knowledge_llama_df <- as.data.frame(m1_knowledge_llama_data)
save(m1_knowledge_llama_df, file = 'llama/m1_knowledge_llama.Rdata')
plot.ts(m1_knowledge_llama_df)
hist(unlist_m1_k_pwu)
filtered_m1_k_pwu <- remove_outliers(unlist_m1_k_pwu)
hist(filtered_m1_k_pwu)
log_df = log(filtered_m1_k_pwu)
for (x in 1:3) {
log_df = log(log_df)
}
hist(log_df)
shapiro.test(log_df)
log_df = log(filtered_m1_k_pwu)
hist(log_df)
log_df = log2(filtered_m1_k_pwu)
hist(log_df)
log_df = log10(filtered_m1_k_pwu)
hist(log_df)
shapiro.test(log_df)
summary(log_df)
hist(log_df)
